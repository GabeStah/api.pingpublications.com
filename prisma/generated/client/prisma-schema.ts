// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
  type AggregateCommit {
    count: Int!
  }

  type AggregateOrganization {
    count: Int!
  }

  type AggregateOwner {
    count: Int!
  }

  type AggregatePost {
    count: Int!
  }

  type AggregateRepository {
    count: Int!
  }

  type AggregateUser {
    count: Int!
  }

  type BatchPayload {
    count: Long!
  }

  type Commit {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    author(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [User!]
    committedDate: DateTime!
    hash: String!
    message: String!
    messageHeadline: String!
    status: CommitStatus!
  }

  type CommitConnection {
    pageInfo: PageInfo!
    edges: [CommitEdge]!
    aggregate: AggregateCommit!
  }

  input CommitCreateInput {
    id: ID
    author: UserCreateManyInput
    committedDate: DateTime!
    hash: String!
    message: String!
    messageHeadline: String!
    status: CommitStatus
  }

  input CommitCreateManyInput {
    create: [CommitCreateInput!]
    connect: [CommitWhereUniqueInput!]
  }

  type CommitEdge {
    node: Commit!
    cursor: String!
  }

  enum CommitOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    committedDate_ASC
    committedDate_DESC
    hash_ASC
    hash_DESC
    message_ASC
    message_DESC
    messageHeadline_ASC
    messageHeadline_DESC
    status_ASC
    status_DESC
  }

  type CommitPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    committedDate: DateTime!
    hash: String!
    message: String!
    messageHeadline: String!
    status: CommitStatus!
  }

  input CommitScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    committedDate: DateTime
    committedDate_not: DateTime
    committedDate_in: [DateTime!]
    committedDate_not_in: [DateTime!]
    committedDate_lt: DateTime
    committedDate_lte: DateTime
    committedDate_gt: DateTime
    committedDate_gte: DateTime
    hash: String
    hash_not: String
    hash_in: [String!]
    hash_not_in: [String!]
    hash_lt: String
    hash_lte: String
    hash_gt: String
    hash_gte: String
    hash_contains: String
    hash_not_contains: String
    hash_starts_with: String
    hash_not_starts_with: String
    hash_ends_with: String
    hash_not_ends_with: String
    message: String
    message_not: String
    message_in: [String!]
    message_not_in: [String!]
    message_lt: String
    message_lte: String
    message_gt: String
    message_gte: String
    message_contains: String
    message_not_contains: String
    message_starts_with: String
    message_not_starts_with: String
    message_ends_with: String
    message_not_ends_with: String
    messageHeadline: String
    messageHeadline_not: String
    messageHeadline_in: [String!]
    messageHeadline_not_in: [String!]
    messageHeadline_lt: String
    messageHeadline_lte: String
    messageHeadline_gt: String
    messageHeadline_gte: String
    messageHeadline_contains: String
    messageHeadline_not_contains: String
    messageHeadline_starts_with: String
    messageHeadline_not_starts_with: String
    messageHeadline_ends_with: String
    messageHeadline_not_ends_with: String
    status: CommitStatus
    status_not: CommitStatus
    status_in: [CommitStatus!]
    status_not_in: [CommitStatus!]
    AND: [CommitScalarWhereInput!]
    OR: [CommitScalarWhereInput!]
    NOT: [CommitScalarWhereInput!]
  }

  enum CommitStatus {
    Pending
    Processed
  }

  type CommitSubscriptionPayload {
    mutation: MutationType!
    node: Commit
    updatedFields: [String!]
    previousValues: CommitPreviousValues
  }

  input CommitSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: CommitWhereInput
    AND: [CommitSubscriptionWhereInput!]
    OR: [CommitSubscriptionWhereInput!]
    NOT: [CommitSubscriptionWhereInput!]
  }

  input CommitUpdateDataInput {
    author: UserUpdateManyInput
    committedDate: DateTime
    hash: String
    message: String
    messageHeadline: String
    status: CommitStatus
  }

  input CommitUpdateInput {
    author: UserUpdateManyInput
    committedDate: DateTime
    hash: String
    message: String
    messageHeadline: String
    status: CommitStatus
  }

  input CommitUpdateManyDataInput {
    committedDate: DateTime
    hash: String
    message: String
    messageHeadline: String
    status: CommitStatus
  }

  input CommitUpdateManyInput {
    create: [CommitCreateInput!]
    update: [CommitUpdateWithWhereUniqueNestedInput!]
    upsert: [CommitUpsertWithWhereUniqueNestedInput!]
    delete: [CommitWhereUniqueInput!]
    connect: [CommitWhereUniqueInput!]
    set: [CommitWhereUniqueInput!]
    disconnect: [CommitWhereUniqueInput!]
    deleteMany: [CommitScalarWhereInput!]
    updateMany: [CommitUpdateManyWithWhereNestedInput!]
  }

  input CommitUpdateManyMutationInput {
    committedDate: DateTime
    hash: String
    message: String
    messageHeadline: String
    status: CommitStatus
  }

  input CommitUpdateManyWithWhereNestedInput {
    where: CommitScalarWhereInput!
    data: CommitUpdateManyDataInput!
  }

  input CommitUpdateWithWhereUniqueNestedInput {
    where: CommitWhereUniqueInput!
    data: CommitUpdateDataInput!
  }

  input CommitUpsertWithWhereUniqueNestedInput {
    where: CommitWhereUniqueInput!
    update: CommitUpdateDataInput!
    create: CommitCreateInput!
  }

  input CommitWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    author_every: UserWhereInput
    author_some: UserWhereInput
    author_none: UserWhereInput
    committedDate: DateTime
    committedDate_not: DateTime
    committedDate_in: [DateTime!]
    committedDate_not_in: [DateTime!]
    committedDate_lt: DateTime
    committedDate_lte: DateTime
    committedDate_gt: DateTime
    committedDate_gte: DateTime
    hash: String
    hash_not: String
    hash_in: [String!]
    hash_not_in: [String!]
    hash_lt: String
    hash_lte: String
    hash_gt: String
    hash_gte: String
    hash_contains: String
    hash_not_contains: String
    hash_starts_with: String
    hash_not_starts_with: String
    hash_ends_with: String
    hash_not_ends_with: String
    message: String
    message_not: String
    message_in: [String!]
    message_not_in: [String!]
    message_lt: String
    message_lte: String
    message_gt: String
    message_gte: String
    message_contains: String
    message_not_contains: String
    message_starts_with: String
    message_not_starts_with: String
    message_ends_with: String
    message_not_ends_with: String
    messageHeadline: String
    messageHeadline_not: String
    messageHeadline_in: [String!]
    messageHeadline_not_in: [String!]
    messageHeadline_lt: String
    messageHeadline_lte: String
    messageHeadline_gt: String
    messageHeadline_gte: String
    messageHeadline_contains: String
    messageHeadline_not_contains: String
    messageHeadline_starts_with: String
    messageHeadline_not_starts_with: String
    messageHeadline_ends_with: String
    messageHeadline_not_ends_with: String
    status: CommitStatus
    status_not: CommitStatus
    status_in: [CommitStatus!]
    status_not_in: [CommitStatus!]
    AND: [CommitWhereInput!]
    OR: [CommitWhereInput!]
    NOT: [CommitWhereInput!]
  }

  input CommitWhereUniqueInput {
    id: ID
    hash: String
  }

  scalar DateTime

  scalar Long

  type Mutation {
    createCommit(data: CommitCreateInput!): Commit!
    updateCommit(
      data: CommitUpdateInput!
      where: CommitWhereUniqueInput!
    ): Commit
    updateManyCommits(
      data: CommitUpdateManyMutationInput!
      where: CommitWhereInput
    ): BatchPayload!
    upsertCommit(
      where: CommitWhereUniqueInput!
      create: CommitCreateInput!
      update: CommitUpdateInput!
    ): Commit!
    deleteCommit(where: CommitWhereUniqueInput!): Commit
    deleteManyCommits(where: CommitWhereInput): BatchPayload!
    createOrganization(data: OrganizationCreateInput!): Organization!
    updateOrganization(
      data: OrganizationUpdateInput!
      where: OrganizationWhereUniqueInput!
    ): Organization
    updateManyOrganizations(
      data: OrganizationUpdateManyMutationInput!
      where: OrganizationWhereInput
    ): BatchPayload!
    upsertOrganization(
      where: OrganizationWhereUniqueInput!
      create: OrganizationCreateInput!
      update: OrganizationUpdateInput!
    ): Organization!
    deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
    deleteManyOrganizations(where: OrganizationWhereInput): BatchPayload!
    createOwner(data: OwnerCreateInput!): Owner!
    updateOwner(data: OwnerUpdateInput!, where: OwnerWhereUniqueInput!): Owner
    updateManyOwners(
      data: OwnerUpdateManyMutationInput!
      where: OwnerWhereInput
    ): BatchPayload!
    upsertOwner(
      where: OwnerWhereUniqueInput!
      create: OwnerCreateInput!
      update: OwnerUpdateInput!
    ): Owner!
    deleteOwner(where: OwnerWhereUniqueInput!): Owner
    deleteManyOwners(where: OwnerWhereInput): BatchPayload!
    createPost(data: PostCreateInput!): Post!
    updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
    updateManyPosts(
      data: PostUpdateManyMutationInput!
      where: PostWhereInput
    ): BatchPayload!
    upsertPost(
      where: PostWhereUniqueInput!
      create: PostCreateInput!
      update: PostUpdateInput!
    ): Post!
    deletePost(where: PostWhereUniqueInput!): Post
    deleteManyPosts(where: PostWhereInput): BatchPayload!
    createRepository(data: RepositoryCreateInput!): Repository!
    updateRepository(
      data: RepositoryUpdateInput!
      where: RepositoryWhereUniqueInput!
    ): Repository
    updateManyRepositories(
      data: RepositoryUpdateManyMutationInput!
      where: RepositoryWhereInput
    ): BatchPayload!
    upsertRepository(
      where: RepositoryWhereUniqueInput!
      create: RepositoryCreateInput!
      update: RepositoryUpdateInput!
    ): Repository!
    deleteRepository(where: RepositoryWhereUniqueInput!): Repository
    deleteManyRepositories(where: RepositoryWhereInput): BatchPayload!
    createUser(data: UserCreateInput!): User!
    updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
    updateManyUsers(
      data: UserUpdateManyMutationInput!
      where: UserWhereInput
    ): BatchPayload!
    upsertUser(
      where: UserWhereUniqueInput!
      create: UserCreateInput!
      update: UserUpdateInput!
    ): User!
    deleteUser(where: UserWhereUniqueInput!): User
    deleteManyUsers(where: UserWhereInput): BatchPayload!
  }

  enum MutationType {
    CREATED
    UPDATED
    DELETED
  }

  interface Node {
    id: ID!
  }

  type Organization {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    users(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [User!]
    handle: String!
  }

  type OrganizationConnection {
    pageInfo: PageInfo!
    edges: [OrganizationEdge]!
    aggregate: AggregateOrganization!
  }

  input OrganizationCreateInput {
    id: ID
    users: UserCreateManyInput
    handle: String!
  }

  type OrganizationEdge {
    node: Organization!
    cursor: String!
  }

  enum OrganizationOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    handle_ASC
    handle_DESC
  }

  type OrganizationPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    handle: String!
  }

  type OrganizationSubscriptionPayload {
    mutation: MutationType!
    node: Organization
    updatedFields: [String!]
    previousValues: OrganizationPreviousValues
  }

  input OrganizationSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: OrganizationWhereInput
    AND: [OrganizationSubscriptionWhereInput!]
    OR: [OrganizationSubscriptionWhereInput!]
    NOT: [OrganizationSubscriptionWhereInput!]
  }

  input OrganizationUpdateInput {
    users: UserUpdateManyInput
    handle: String
  }

  input OrganizationUpdateManyMutationInput {
    handle: String
  }

  input OrganizationWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    users_every: UserWhereInput
    users_some: UserWhereInput
    users_none: UserWhereInput
    handle: String
    handle_not: String
    handle_in: [String!]
    handle_not_in: [String!]
    handle_lt: String
    handle_lte: String
    handle_gt: String
    handle_gte: String
    handle_contains: String
    handle_not_contains: String
    handle_starts_with: String
    handle_not_starts_with: String
    handle_ends_with: String
    handle_not_ends_with: String
    AND: [OrganizationWhereInput!]
    OR: [OrganizationWhereInput!]
    NOT: [OrganizationWhereInput!]
  }

  input OrganizationWhereUniqueInput {
    id: ID
    handle: String
  }

  type Owner {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    handle: String!
  }

  type OwnerConnection {
    pageInfo: PageInfo!
    edges: [OwnerEdge]!
    aggregate: AggregateOwner!
  }

  input OwnerCreateInput {
    id: ID
    handle: String!
  }

  input OwnerCreateOneInput {
    create: OwnerCreateInput
    connect: OwnerWhereUniqueInput
  }

  type OwnerEdge {
    node: Owner!
    cursor: String!
  }

  enum OwnerOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    handle_ASC
    handle_DESC
  }

  type OwnerPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    handle: String!
  }

  type OwnerSubscriptionPayload {
    mutation: MutationType!
    node: Owner
    updatedFields: [String!]
    previousValues: OwnerPreviousValues
  }

  input OwnerSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: OwnerWhereInput
    AND: [OwnerSubscriptionWhereInput!]
    OR: [OwnerSubscriptionWhereInput!]
    NOT: [OwnerSubscriptionWhereInput!]
  }

  input OwnerUpdateDataInput {
    handle: String
  }

  input OwnerUpdateInput {
    handle: String
  }

  input OwnerUpdateManyMutationInput {
    handle: String
  }

  input OwnerUpdateOneRequiredInput {
    create: OwnerCreateInput
    update: OwnerUpdateDataInput
    upsert: OwnerUpsertNestedInput
    connect: OwnerWhereUniqueInput
  }

  input OwnerUpsertNestedInput {
    update: OwnerUpdateDataInput!
    create: OwnerCreateInput!
  }

  input OwnerWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    handle: String
    handle_not: String
    handle_in: [String!]
    handle_not_in: [String!]
    handle_lt: String
    handle_lte: String
    handle_gt: String
    handle_gte: String
    handle_contains: String
    handle_not_contains: String
    handle_starts_with: String
    handle_not_starts_with: String
    handle_ends_with: String
    handle_not_ends_with: String
    AND: [OwnerWhereInput!]
    OR: [OwnerWhereInput!]
    NOT: [OwnerWhereInput!]
  }

  input OwnerWhereUniqueInput {
    id: ID
    handle: String
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type Post {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    published: Boolean!
    title: String!
    content: String
    author: User!
  }

  type PostConnection {
    pageInfo: PageInfo!
    edges: [PostEdge]!
    aggregate: AggregatePost!
  }

  input PostCreateInput {
    id: ID
    published: Boolean
    title: String!
    content: String
    author: UserCreateOneInput!
  }

  type PostEdge {
    node: Post!
    cursor: String!
  }

  enum PostOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    published_ASC
    published_DESC
    title_ASC
    title_DESC
    content_ASC
    content_DESC
  }

  type PostPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    published: Boolean!
    title: String!
    content: String
  }

  type PostSubscriptionPayload {
    mutation: MutationType!
    node: Post
    updatedFields: [String!]
    previousValues: PostPreviousValues
  }

  input PostSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: PostWhereInput
    AND: [PostSubscriptionWhereInput!]
    OR: [PostSubscriptionWhereInput!]
    NOT: [PostSubscriptionWhereInput!]
  }

  input PostUpdateInput {
    published: Boolean
    title: String
    content: String
    author: UserUpdateOneRequiredInput
  }

  input PostUpdateManyMutationInput {
    published: Boolean
    title: String
    content: String
  }

  input PostWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    published: Boolean
    published_not: Boolean
    title: String
    title_not: String
    title_in: [String!]
    title_not_in: [String!]
    title_lt: String
    title_lte: String
    title_gt: String
    title_gte: String
    title_contains: String
    title_not_contains: String
    title_starts_with: String
    title_not_starts_with: String
    title_ends_with: String
    title_not_ends_with: String
    content: String
    content_not: String
    content_in: [String!]
    content_not_in: [String!]
    content_lt: String
    content_lte: String
    content_gt: String
    content_gte: String
    content_contains: String
    content_not_contains: String
    content_starts_with: String
    content_not_starts_with: String
    content_ends_with: String
    content_not_ends_with: String
    author: UserWhereInput
    AND: [PostWhereInput!]
    OR: [PostWhereInput!]
    NOT: [PostWhereInput!]
  }

  input PostWhereUniqueInput {
    id: ID
  }

  type Query {
    commit(where: CommitWhereUniqueInput!): Commit
    commits(
      where: CommitWhereInput
      orderBy: CommitOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Commit]!
    commitsConnection(
      where: CommitWhereInput
      orderBy: CommitOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): CommitConnection!
    organization(where: OrganizationWhereUniqueInput!): Organization
    organizations(
      where: OrganizationWhereInput
      orderBy: OrganizationOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Organization]!
    organizationsConnection(
      where: OrganizationWhereInput
      orderBy: OrganizationOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): OrganizationConnection!
    owner(where: OwnerWhereUniqueInput!): Owner
    owners(
      where: OwnerWhereInput
      orderBy: OwnerOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Owner]!
    ownersConnection(
      where: OwnerWhereInput
      orderBy: OwnerOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): OwnerConnection!
    post(where: PostWhereUniqueInput!): Post
    posts(
      where: PostWhereInput
      orderBy: PostOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Post]!
    postsConnection(
      where: PostWhereInput
      orderBy: PostOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): PostConnection!
    repository(where: RepositoryWhereUniqueInput!): Repository
    repositories(
      where: RepositoryWhereInput
      orderBy: RepositoryOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Repository]!
    repositoriesConnection(
      where: RepositoryWhereInput
      orderBy: RepositoryOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): RepositoryConnection!
    user(where: UserWhereUniqueInput!): User
    users(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [User]!
    usersConnection(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): UserConnection!
    node(id: ID!): Node
  }

  type Repository {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    name: String!
    owner: Owner!
    service: RepositoryServiceType!
    commits(
      where: CommitWhereInput
      orderBy: CommitOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Commit!]
  }

  type RepositoryConnection {
    pageInfo: PageInfo!
    edges: [RepositoryEdge]!
    aggregate: AggregateRepository!
  }

  input RepositoryCreateInput {
    id: ID
    name: String!
    owner: OwnerCreateOneInput!
    service: RepositoryServiceType
    commits: CommitCreateManyInput
  }

  type RepositoryEdge {
    node: Repository!
    cursor: String!
  }

  enum RepositoryOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    name_ASC
    name_DESC
    service_ASC
    service_DESC
  }

  type RepositoryPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    name: String!
    service: RepositoryServiceType!
  }

  enum RepositoryServiceType {
    GitHub
    GitLab
    Bitbucket
  }

  type RepositorySubscriptionPayload {
    mutation: MutationType!
    node: Repository
    updatedFields: [String!]
    previousValues: RepositoryPreviousValues
  }

  input RepositorySubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: RepositoryWhereInput
    AND: [RepositorySubscriptionWhereInput!]
    OR: [RepositorySubscriptionWhereInput!]
    NOT: [RepositorySubscriptionWhereInput!]
  }

  input RepositoryUpdateInput {
    name: String
    owner: OwnerUpdateOneRequiredInput
    service: RepositoryServiceType
    commits: CommitUpdateManyInput
  }

  input RepositoryUpdateManyMutationInput {
    name: String
    service: RepositoryServiceType
  }

  input RepositoryWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    name: String
    name_not: String
    name_in: [String!]
    name_not_in: [String!]
    name_lt: String
    name_lte: String
    name_gt: String
    name_gte: String
    name_contains: String
    name_not_contains: String
    name_starts_with: String
    name_not_starts_with: String
    name_ends_with: String
    name_not_ends_with: String
    owner: OwnerWhereInput
    service: RepositoryServiceType
    service_not: RepositoryServiceType
    service_in: [RepositoryServiceType!]
    service_not_in: [RepositoryServiceType!]
    commits_every: CommitWhereInput
    commits_some: CommitWhereInput
    commits_none: CommitWhereInput
    AND: [RepositoryWhereInput!]
    OR: [RepositoryWhereInput!]
    NOT: [RepositoryWhereInput!]
  }

  input RepositoryWhereUniqueInput {
    id: ID
  }

  type Subscription {
    commit(where: CommitSubscriptionWhereInput): CommitSubscriptionPayload
    organization(
      where: OrganizationSubscriptionWhereInput
    ): OrganizationSubscriptionPayload
    owner(where: OwnerSubscriptionWhereInput): OwnerSubscriptionPayload
    post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
    repository(
      where: RepositorySubscriptionWhereInput
    ): RepositorySubscriptionPayload
    user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  }

  type User {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    email: String!
    name: String
    handle: String!
  }

  type UserConnection {
    pageInfo: PageInfo!
    edges: [UserEdge]!
    aggregate: AggregateUser!
  }

  input UserCreateInput {
    id: ID
    email: String!
    name: String
    handle: String!
  }

  input UserCreateManyInput {
    create: [UserCreateInput!]
    connect: [UserWhereUniqueInput!]
  }

  input UserCreateOneInput {
    create: UserCreateInput
    connect: UserWhereUniqueInput
  }

  type UserEdge {
    node: User!
    cursor: String!
  }

  enum UserOrderByInput {
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    email_ASC
    email_DESC
    name_ASC
    name_DESC
    handle_ASC
    handle_DESC
  }

  type UserPreviousValues {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    email: String!
    name: String
    handle: String!
  }

  input UserScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    email: String
    email_not: String
    email_in: [String!]
    email_not_in: [String!]
    email_lt: String
    email_lte: String
    email_gt: String
    email_gte: String
    email_contains: String
    email_not_contains: String
    email_starts_with: String
    email_not_starts_with: String
    email_ends_with: String
    email_not_ends_with: String
    name: String
    name_not: String
    name_in: [String!]
    name_not_in: [String!]
    name_lt: String
    name_lte: String
    name_gt: String
    name_gte: String
    name_contains: String
    name_not_contains: String
    name_starts_with: String
    name_not_starts_with: String
    name_ends_with: String
    name_not_ends_with: String
    handle: String
    handle_not: String
    handle_in: [String!]
    handle_not_in: [String!]
    handle_lt: String
    handle_lte: String
    handle_gt: String
    handle_gte: String
    handle_contains: String
    handle_not_contains: String
    handle_starts_with: String
    handle_not_starts_with: String
    handle_ends_with: String
    handle_not_ends_with: String
    AND: [UserScalarWhereInput!]
    OR: [UserScalarWhereInput!]
    NOT: [UserScalarWhereInput!]
  }

  type UserSubscriptionPayload {
    mutation: MutationType!
    node: User
    updatedFields: [String!]
    previousValues: UserPreviousValues
  }

  input UserSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: UserWhereInput
    AND: [UserSubscriptionWhereInput!]
    OR: [UserSubscriptionWhereInput!]
    NOT: [UserSubscriptionWhereInput!]
  }

  input UserUpdateDataInput {
    email: String
    name: String
    handle: String
  }

  input UserUpdateInput {
    email: String
    name: String
    handle: String
  }

  input UserUpdateManyDataInput {
    email: String
    name: String
    handle: String
  }

  input UserUpdateManyInput {
    create: [UserCreateInput!]
    update: [UserUpdateWithWhereUniqueNestedInput!]
    upsert: [UserUpsertWithWhereUniqueNestedInput!]
    delete: [UserWhereUniqueInput!]
    connect: [UserWhereUniqueInput!]
    set: [UserWhereUniqueInput!]
    disconnect: [UserWhereUniqueInput!]
    deleteMany: [UserScalarWhereInput!]
    updateMany: [UserUpdateManyWithWhereNestedInput!]
  }

  input UserUpdateManyMutationInput {
    email: String
    name: String
    handle: String
  }

  input UserUpdateManyWithWhereNestedInput {
    where: UserScalarWhereInput!
    data: UserUpdateManyDataInput!
  }

  input UserUpdateOneRequiredInput {
    create: UserCreateInput
    update: UserUpdateDataInput
    upsert: UserUpsertNestedInput
    connect: UserWhereUniqueInput
  }

  input UserUpdateWithWhereUniqueNestedInput {
    where: UserWhereUniqueInput!
    data: UserUpdateDataInput!
  }

  input UserUpsertNestedInput {
    update: UserUpdateDataInput!
    create: UserCreateInput!
  }

  input UserUpsertWithWhereUniqueNestedInput {
    where: UserWhereUniqueInput!
    update: UserUpdateDataInput!
    create: UserCreateInput!
  }

  input UserWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    email: String
    email_not: String
    email_in: [String!]
    email_not_in: [String!]
    email_lt: String
    email_lte: String
    email_gt: String
    email_gte: String
    email_contains: String
    email_not_contains: String
    email_starts_with: String
    email_not_starts_with: String
    email_ends_with: String
    email_not_ends_with: String
    name: String
    name_not: String
    name_in: [String!]
    name_not_in: [String!]
    name_lt: String
    name_lte: String
    name_gt: String
    name_gte: String
    name_contains: String
    name_not_contains: String
    name_starts_with: String
    name_not_starts_with: String
    name_ends_with: String
    name_not_ends_with: String
    handle: String
    handle_not: String
    handle_in: [String!]
    handle_not_in: [String!]
    handle_lt: String
    handle_lte: String
    handle_gt: String
    handle_gte: String
    handle_contains: String
    handle_not_contains: String
    handle_starts_with: String
    handle_not_starts_with: String
    handle_ends_with: String
    handle_not_ends_with: String
    AND: [UserWhereInput!]
    OR: [UserWhereInput!]
    NOT: [UserWhereInput!]
  }

  input UserWhereUniqueInput {
    id: ID
    email: String
    handle: String
  }
`;
